use std::default::Default;
use std::ops::{Index, IndexMut};

// Conventions!
//
// We always, *ALWAYS*, refer to width, height, in that order.  The
// position of a node on a _grid_ is therefore always `y * width + x`,
// that is, the number of rows DOWN is calculated as an offset
// multiple of the width, followed by the offset into the row to find
// the node.
//
// For navigation, we always, *ALWAYS*, talk about movement along the
// X-axis first, then the Y-axis second.
//
// Following the standard mental model for grids, the upper-left-hand
// corner is the origin, and all calculations thereafter progress
// RIGHT or DOWN, and the offsets in those directions are positive.
// Going UP or LEFT is a negative direction.
//
// The eight-cell collection of node pointers skips the center, but
// otherwise follows a predictable course from top to bottom, left to
// right.

macro_rules! cq {
	($condition: expr, $_true: expr, $_false: expr) => {
		if $condition {
			$_true
		} else {
			$_false
			}
	};
}

const UP: i32 = -1;
const DN: i32 = 1;
const LF: i32 = -1;
const RT: i32 = 1;
const SM: i32 = 0;

#[allow(unused_macros)]
macro_rules! dm {
	(LF, UP) => {
			0
	};
	(SM, UP) => {
			1
	};
	(RT, UP) => {
			2
	};
	(LF, SM) => {
			3
	};
	(RT, SM) => {
			4
	};
	(LF, DN) => {
			5
	};
	(SM, DN) => {
			6
	};
	(RT, DN) => {
			7
	};
}

pub fn dm(y: i32, x: i32) -> u32 {
	match (y, x) {
		(LF, UP) => 0,
		(SM, UP) => 1,
		(RT, UP) => 2,
		(LF, SM) => 3,
		(RT, SM) => 4,
		(LF, DN) => 5,
		(SM, DN) => 6,
		(RT, DN) => 7,
		_ => panic!("This should not happen"),
	}
}

#[derive(Debug, Default, Clone)]
pub struct Point<P>
where
	P: std::default::Default + Copy,
{
	pub neighbors: [u32; 8],
	pub data: P,
}

type NodeId = u32;

pub struct SeamLattice<P: Default + Copy> {
	pub width: u32,
	pub height: u32,
	pub root: NodeId,
	data: Vec<Point<P>>,
}

fn initialize_lattice<P: Default + Copy>(width: u32, height: u32, data: &mut Vec<Point<P>>) {
	let mw = width - 1;
	let mh = height - 1;

	for h in 0..height {
		for w in 0..width {
			for hstep in UP..=DN {
				for wstep in LF..=RT {
					if hstep == 0 && wstep == 0 {
						continue;
					}
					let pos = (h as usize) * (width as usize) + (w as usize);
					let node_ptr = dm(wstep, hstep);
					data[pos].neighbors[node_ptr as usize] = {
						let hpoint = (h as i32) + hstep;
						let wpoint = (w as i32) + wstep;
						if hpoint < 0 || hpoint > mh as i32 || wpoint < 0 || wpoint > mw as i32 {
							pos as u32
						} else {
							width * (hpoint as u32) + (wpoint as u32)
						}
					};
				}
			}
		}
	}
}

// Brainstorming: the visitor "needs" to visit any number of points on
// the grid.  So it either knows its root-- or can retrieve it.
// Visitors need to be clone-able, or at least reproducible from a
// factory for the purpose of aggregating multi-core soltions.  So,
// the visitor visits a node... then what?  Somehow signals that it
// needs the next node in a given direction, or that it's done.

// Even worse, imagine this: the COLUMN visitor is visiting rows, but
// for each COLUMN it then produces a new ROW of data, which then has
// to be written back to the core data structure in order to record
// the unit of work.  So we have a dance, and at its heart is a
// mutation, and that's.. difficult.

// All right, so what do we need?  We need a visitor object related to
// the lattice.  It, in turn, takes... what?  A function?  A closure?
// The objective here is to a function, process a node, and either
// move on to a new node to apply the function, or quit.  Why quit?
// Because the function has reached a certain point, or because you've
// run out of nodes to visit: you've hit an edge, a place where the
// direction you're about to move to returns the same node.

// So we have two *different* functions: one for visit, which does not
// mutate the lattice, and visit_mut, which does mutate every point in
// the lattice.  The latter is used to write back data generated by
// the various maths functions.

// Maybe we could use two different lattices?  All right, let's solve
// the easy version first: no threads.

impl<P: Default + Copy> SeamLattice<P> {
	pub fn new(width: u32, height: u32) -> Self {
		let mut data = vec![Point::<P>::default(); width as usize * height as usize];
		initialize_lattice(width, height, &mut data);
		SeamLattice {
			width,
			height,
			root: 0,
			data,
		}
	}

	pub fn create_from_grid(width: u32, height: u32, source: &Vec<P>) -> Self {
		let mut data = vec![Point::<P>::default(); width as usize * height as usize];
		initialize_lattice(width, height, &mut data);
		(0..(width * height) as usize).for_each(|i| {
			data[i].data = source[i];
		});
		SeamLattice {
			width,
			height,
			root: 0,
			data,
		}
	}

	pub fn transit_by_direction(&self, node: u32, direction: u32) -> NodeId {
		self.data[node as usize].neighbors[direction as usize]
	}

	pub fn transit(&self, node: u32, x: i32, y: i32) -> NodeId {
		self.transit_by_direction(node, dm(x, y))
	}
}

impl<P: Default + Copy> Index<u32> for SeamLattice<P> {
	type Output = P;

	/// A convenience addressing mode for getting values.
	fn index(&self, p: NodeId) -> &P {
		&self.data[p as usize].data
	}
}

impl<P: Default + Copy> IndexMut<u32> for SeamLattice<P> {
	/// A convenience addressing mode for setting values.
	fn index_mut(&mut self, p: u32) -> &mut P {
		&mut self.data[p as usize].data
	}
}

impl<P: Default + Copy + std::fmt::Debug> std::fmt::Debug for SeamLattice<P> {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		writeln!(
			f,
			"SeamLattice {{ width: {}, height: {}, root: {}",
			self.width, self.height, self.root
		)
		.unwrap();
		for i in &self.data {
			writeln!(f, "    {:?}", i).unwrap();
		}
		writeln!(f, "}}")
	}
}

/// This trait takes a lattice and returns a new NodeId, indicating
/// where the next step should be.
pub trait WalkStep<P: Default + Copy> {
	fn step(&mut self, lattice: &SeamLattice<P>) -> Option<NodeId>;
}

/// A walker takes a Step (which must understandably last at least as
/// long as the Walker), and for each call of `next()` returns the
/// content of the node indicated by Step (`Some(P)`), or `None`.
pub struct Walker<P: Default + Copy> {
	prev_node_id: Option<NodeId>,
	step: Box<dyn WalkStep<P>>,
}

impl<'a, P: Default + Copy + std::fmt::Display> Walker<P> {
	pub fn new(step: Box<dyn WalkStep<P>>) -> Walker<P> {
		Walker {
			prev_node_id: None,
			step,
		}
	}
	pub fn next(&mut self, lattice: &'a SeamLattice<P>) -> Option<&'a P> {
		let node_id = self.step.step(&lattice);
		match node_id {
			None => None,
			Some(node_id) => {
				if let Some(prev_node_id) = self.prev_node_id {
					if prev_node_id == node_id {
						return None;
					}
				}
				let data = &lattice.data[node_id as usize].data;
				self.prev_node_id = Some(node_id);
				println!("{}", data);
				Some(data)
			}
		}
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn smallest_possible_grid() {
		let _grid: SeamLattice<u32> = SeamLattice::new(1, 1);
		assert!(true, "Grid constructed");
	}

	#[test]
	fn smallest_grid_is_self_referring() {
		let grid: SeamLattice<u32> = SeamLattice::new(1, 1);
		let root = grid.root;
		for i in UP..=DN {
			for j in LF..=RT {
				if i == 0 && j == 0 {
					continue;
				}
				assert_eq!(
					grid.transit(root, i, j),
					root,
					"One node transition was not self-referring"
				)
			}
		}
	}

	macro_rules! test_dm {
		($grid:expr, $root:expr, $i:ident, $j:ident) => {
			assert_eq!(
				$grid.transit_by_direction($root, dm!($i, $j)),
				$root,
				"One node transition was not self-referring in macro"
			);
		};
	}

	#[test]
	fn smallest_grid_is_statically_self_referring() {
		let grid: SeamLattice<u32> = SeamLattice::new(1, 1);
		let root = grid.root;
		test_dm!(grid, root, LF, UP);
		test_dm!(grid, root, SM, UP);
		test_dm!(grid, root, RT, UP);
		test_dm!(grid, root, LF, SM);
		test_dm!(grid, root, RT, SM);
		test_dm!(grid, root, LF, DN);
		test_dm!(grid, root, SM, DN);
		test_dm!(grid, root, LF, DN);
	}

	#[test]
	fn triple_grid_is_self_referring() {
		let grid: SeamLattice<u32> =
			SeamLattice::create_from_grid(3, 3, &vec![10, 11, 12, 13, 14, 15, 16, 17, 18]);
		let center = grid.transit(grid.root, DN, RT);
		assert_eq!(grid[center], 14);

		assert_eq!(grid[grid.transit(center, LF, UP)], 10);
		assert_eq!(grid[grid.transit(center, SM, UP)], 11);
		assert_eq!(grid[grid.transit(center, RT, UP)], 12);
		assert_eq!(grid[grid.transit(center, LF, SM)], 13);
		assert_eq!(grid[grid.transit(center, RT, SM)], 15);
		assert_eq!(grid[grid.transit(center, LF, DN)], 16);
		assert_eq!(grid[grid.transit(center, SM, DN)], 17);
		assert_eq!(grid[grid.transit(center, RT, DN)], 18);
	}

	struct Summer(NodeId);
	impl WalkStep<u32> for Summer {
		fn step(&mut self, lattice: &SeamLattice<u32>) -> Option<NodeId> {
			let cur = self.0;
			self.0 = lattice.transit(self.0, RT, SM);
			Some(cur)
		}
	}

	fn visit(walker: &mut Walker<u32>, lattice: &SeamLattice<u32>) -> u32 {
		let mut total = 0;
		while let Some(v) = walker.next(lattice) {
			total += *v;
		}
		total
	}

	fn build_walker(node_id: NodeId) -> Walker<u32> {
		Walker::new(Box::new(Summer(node_id)))
	}

	#[test]
	fn visit_threeby_grid() {
		let grid: SeamLattice<u32> =
			SeamLattice::create_from_grid(3, 3, &vec![10, 11, 12, 13, 14, 15, 16, 17, 18]);

		println!("{:?}", grid);

		let mut walker = build_walker(0);
		assert_eq!(visit(&mut walker, &grid), 33);

		let mut walker = build_walker(3);
		assert_eq!(visit(&mut walker, &grid), 42);

		let mut walker = build_walker(6);
		assert_eq!(visit(&mut walker, &grid), 51);
	}
}
